
unit test marshalling:
create a function that at runtime checks that the size of c++ types matches the size of the C# types we match up the c++ types with.
For instance, the c++ function would return the size of time_t, and c# would then compare to the size of long (which is the type that c# matches up with .time_t). Add a unit test that calls this function
(1 hour. perhaps extra time for debugging)

unit test marshalling:
create a function that at runtime round-trips the types we use in marshalling with some edge cases to ensure that the p/invoke on the current platform
works as we expect. That is... 
1) function that return edge cases of values, that originate at the c++ end
2) call with values from C#, validated at the c++ end
3) round-trip of values sent from c# and received again
(3-4 hours)



Design (naming and operator overload) desicion
is table similar to an array?
is it similar to an ArrayList?
is it similar an List<T>?   (where T is either a RowColumn or a typed something derived from RowColumn)

ArrayList 
- indexed by number
- each element can be of any type
- if the elements implement compareto, arraylist can sort itself
- grows when more is added

List<T>
- type safe for type T, that is, each instance of list<T> only takes the T type
- if we want to use this, we should emulate a list<T> where <T> is Row

- we can also introduce our own type, Table that implements iterator and quacks a bit like an arraylist

Anyway - - 

naming - name table etc. methods after this template :
1) if the functionality exists in ArrayList, use that name
2) if not, then use the tightdb c++ naming





update github with project files
(1 hour as project setup now seem to be quite stable)

These next 4 tasks are done in parrallel, each lowlevel function is done on all levels, to ensure it works (sb. covered by at least one unit test)
before carrying on, and to ensure the architecture is sound. While the estimate is 4-8 days, we'll probably be missing only a few select (difficult) things towards the end. We should have a working system while this task is ongoing.

implement sharedgroup
(hours)

implement the rest of the types and any other functions in c++
(1-2 days)

implement the rest of the types, and any other functions on the c# side
(1-2 days)

implement the rest of the types, and any other functions in the C# classes
(1-2 days)

create unit tests that touch every c++ function
(1-2 days)

create unit tests that excercize all C# lines
(a week?)

consider that columntypes are always the same for all rows (if mixed is treated as a type). If so - move columntype out of tablerowcolumn and down into table in some seperate (nonchanging,except when columns are added or deleted) structure. Could be as simple as an array of datatype.
Mixed will probably have to be handled on the row level, or passed on to tightdb.
If subsequent columntype lookups at table level can be looked up on the c# side without calling c++ it will likely be faster as we wo't have to do a pinvoke call.
(2 hr)

"create distribution" instructions - should create a zip file with the stuff needed to run on a 32bit windows PC with newest .net and VS2012 (less than 1hr)

"create distribution" instructions - should create a zip file with the stuff needed to run on a 64bit windows PC with newest .net and VS2012 (less than 1hr)

implement C# support for Linq using Ienumerator and C#'s own LinQ engine
(done in principle (table now supports being enummerated) needs some LINQ specific testing - 1 day, problems could be troublesome to fix)

implement C# support for LinQ using IQueryable<t>
(probably a day to figure how long it takes, and what should be done)

implement a typed tightdb vesion in C#
(? days - We might be able to use T4, it seems to be supported in mono too. In the case that T4 will work for our needs, this tasks will then revolve around developing the typed interface in C#. As this is a re-implementation of the java and c++ typed interfaces (so no interop/c++ stuff) We should see a lot of functionality as a function of time spent. I wil get back to a more precise estimate when I have read up on the scope and size of the typed interface) 

Create virtual 32 bit windows to be used for testing
(1 day)

Create virtual 64 bit windows to be used for testing
(1 day)

(most of the time spent in the above 2 tasks is installing windows, .net and visual studio and perhaps nunit - we can save quite some time if we decide just to try it out on existing windows installations we have access to -and wait with the rest to some other time)

verify that the 32bit distribution installs and works well on a freshly installed 32 bit windows .net installation
(<1 hour)

verify that the 32bit distribution installs and works well on a freshly installed 64 bit windows (running on WOW64)
(<1 hour)

verify that the 64bit distribution installs and works well on a freshly installed 64 bit windows running x64
(<1 hour)

test that AnyCpu user project using TightDbCSharp runs/works on mono on windows 32bit
(0-2 days, uncertain)

test that AnyCpu user project using TightDbCSharp runs/works on mono on windows 64bit
(0-2 days, uncertain)

test that 32bit user project using TightDbCSharp runs/works on mono on windows 32bit
(0-2 days, uncertain)

test that 32bit user project using TightDbCSharp runs/works on mono on windows 64bit
(0-2 days, uncertain)

test that 64bit user project using TightDbCSharp runs/works on mono on windows 64bit
(0-2 days, uncertain)

support for mono on (a selected common flavor of linux) 32bit (we will need to recompile, perhaps modify the Tight_c_cs c++ dll and the NativeCalls.cs)
(? days)

support for mono on (a selected common flavor of linux) linux 64bit (we will need to recompile, perhaps modify the Tight_c_cs c++ dll and the NativeCalls.cs)
(? days)

support for mono on Ios 32bit (we will need to recompile, perhaps modify the Tight_c_cs c++ dll and the NativeCalls.cs)
(? days)

support for mono on Ios 64bit (we will need to recompile, perhaps modify the Tight_c_cs c++ dll and the NativeCalls.cs)
(? days)

create benchmarks

create documentation

create examples of usage, using various features of tightdb

create a test project that shows the binding in action on a "real-life" type problem
